/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>
#include "I2Cx.h"
#include "RCC.h"
#include "GPIOx.h"
#include "NVIC.h"
/*#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/
//**Direcciones del DS1307
int AdreDS1307 =0x68;///Dirección del RTC DS1307
int AdreSec= 0x00;
int AdreMin=0x01;
// Variables para manejar los valores del RTC
//uint8_t segundos, minutos, horas, dia, fecha, mes, anio;
uint32_t i;
uint8_t buffer[8]= {0xf} , bufferI2CTx[8];
I2C_HandlerDef *direccion;
uint8_t *buff;
/*
uint8_t buffersym[2];
uint8_t bufferhyd[2];
uint8_t bufferfym[2];
*/
//
void CargarFecha();
void leerFecha();
void I2Cx_ResetStruct( I2C_HandlerDef * i2c ,I2C_TypeDef * i2cbase);
int main(void)
{
	//Los prescaladores se seleccionan por n=1,2,...,8. Siendo 2^n el valor del preescalador
	SystClock_Init(2,0,78,1,0,0);//SYSCLK -> PLLP, SYSPLL -> HSI, SYSCLK -> 80MHz, preAHB1 -> divided by 2^1
	 //preAPB1 -> Not divided, preAPB2 -> not divided, APB1 = 40MHZ, APB2=40MHz.
	I2Cx_ResetStruct(&I2C1_Struct, I2C1_R);
	I2Cx_GPIO_Init(true, I2C1);//pull up on
	I2Cx_Init(39,0,&I2C1_Struct);//10MHz, 0 -> Standard mode; 1 -> Fast Mode
	NVIC_SetCFGR(NVIC_I2C1EV_POSITION, 3);
	NVIC_SetCFGR(NVIC_I2C1ER_POSITION, 4);
	I2Cx_DisableIT(&I2C1_Struct);
	I2Cx_ADDRSet(AdreDS1307, 0, 0, &I2C1_Struct);//Address of Device, 0 -> 7 bits addressing, 0 -> APB1_freq (Set Only in 10 bits and Master Mode)
//	I2Cx_ResetACK(&I2C1_Struct);
	direccion=&I2C1_Struct;
	buff=bufferI2C;
//	CargarFecha(); // Función para configurar al esclavo RTC DS1307
//	for (i = 0; i < 5000000; ++i) ;
	buffer[0]=0x00,  buffer[1]=0x40,  buffer[2]=0x09,  buffer[3]=0x04,  buffer[4]=0x31,  buffer[5]=0x10,  buffer[6]=0x19;
	//bufferI2CTx[0]=AdreSec, bufferI2CTx[1]=0x00,  bufferI2CTx[2]=0x40,  bufferI2CTx[3]=0x09,  bufferI2CTx[4]=0x04,  bufferI2CTx[5]=0x31,  bufferI2CTx[6]=0x10,  bufferI2CTx[7]=0x19;
	//I2Cx_SlaveTx_IT(7, bufferI2CTx, &I2C1_Struct);
	while(1){
		//bufferI2CTx[0]++;
		//for (i = 0; i < 10000000; ++i) ;
//	    leerFecha();
		I2Cx_SlaveTx(buffer, 7, &I2C1_Struct);
		I2Cx_DisableIT(&I2C1_Struct);
		i++;
		buffer[0]=i;
		I2Cx_SlaveRx(bufferI2C, 8, &I2C1_Struct);
		I2Cx_DisableIT(&I2C1_Struct);
	}
}
//RTC Incrementa la dirección o se puede ir escribiendo por una
//primero mandando la dirección y luego el dato, lo mismo con la lectura
void CargarFecha(){
//	uint8_t buff[8];
    /*
     Programar: Jueves 31 de octubre del 2019, a las 9:40:00 pm

    El mapa de memoria del DS1207 es el siguiente:
    DIRECCIÓN  FUNCIÓN    BIT7   BIT6  BIT5  BIT4  BIT3  BIT2  BIT1   BIT0
        00h    Segundos     0     0     0      0    0      0    0       0
        01h     Minutos     0     0     0      0    0      0    0       0
        02h     Horas       0     0     0      1    0      0    0       0
        03h     Día         0     0     1      1    0      0    0       1
        04h     Fecha       0     0     0      0    0      1    0       0
        05h     Mes         0     0     0      1    0      0    0       0
        06h     Año         0     0     0      1    1      0    0       1
        07h     Control     0     0     0      0    0      0    1       1
     08h-3Fh    RAM 56x8
     */
    //Por lo tanto

	//buff[0]=AdreSec, buff[1]=0x00,  buff[2]=0x40,  buff[3]=0x09,  buff[4]=0x04,  buff[5]=0x31,  buff[6]=0x10,  buff[7]=0x19;
	bufferI2C[0]=AdreSec, bufferI2C[1]=0x00,  bufferI2C[2]=0x40,  bufferI2C[3]=0x09,  bufferI2C[4]=0x04,  bufferI2C[5]=0x31,  bufferI2C[6]=0x10,  bufferI2C[7]=0x19;
	//Sin interrupción
	I2Cx_MasterTx(AdreDS1307, bufferI2C, 8, &I2C1_Struct);
	I2Cx_WaitBUSYReset(&I2C1_Struct);
	//Con interrupción
	//I2Cx_MasterTx_IT(AdreDS1307, 8, bufferI2C, &I2C1_Struct);
	//for (i = 0; i < 500000; ++i) ;
}
//Se puede enviar la dirección desde la cuál comenzará y después se leen los datos
//O se puede ir leyendo una a una, transmitiendo y recibiendo
void leerFecha(){
	//Sin interrupción
	I2Cx_MasterTx(AdreDS1307, 0, 1, &I2C1_Struct);
	I2Cx_WaitBUSYReset(&I2C1_Struct);
	I2Cx_MasterRx(AdreDS1307, buffer, 7, &I2C1_Struct);
	I2Cx_WaitBUSYReset(&I2C1_Struct);
	//Con interrupción
	//I2Cx_EnableIT(&I2C1_Struct);
	//bufferI2C[0]=0;
//	I2Cx_MasterTx_IT(AdreDS1307, 1, 0, &I2C1_Struct);
//	for (i = 0; i < 5000000; ++i) ;
//	I2Cx_MasterRx_IT(AdreDS1307, 7, bufferI2CRx, &I2C1_Struct);
//	for (i = 0; i < 500000; ++i) ;
}

void I2Cx_ResetStruct( I2C_HandlerDef * i2c ,I2C_TypeDef * i2cbase){
    i2c->Registers = i2cbase;
    i2c->Parameter.ADDRDevice=0;
    i2c->Parameter.TX_RX_mode=0;
    i2c->Parameter.modeAddressing=0;
    i2c->Parameter.own_address=0;
    i2c->currentState=0;

}
