/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "GPIOx.h"
#include "RCC.h"
#include "SYSTICK.h"
#include "NVIC.h"

#include "CANx.h"

void CANx_SetParFLTR(CAN_FilterTypeDef * FLTR, uint8_t index, uint8_t scale, uint16_t IDL, uint16_t IDH,
		uint16_t MaskL, uint32_t MaskH, uint8_t mode, uint8_t FIFO, bool IDE);
void CANx_SetParDualFLTR(CAN_DualFilterID_n_MaskTypeDef * FLTR, uint8_t index, uint16_t IDL, uint16_t IDH, uint16_t MaskL, uint16_t MaskH);

uint32_t dataRx[5], i, dato=1;


int main(void)
{
	CAN_FilterTypeDef FLTR[2];
	CAN_DualFilterID_n_MaskTypeDef dualFLTR[1];
	CAN_Handler can;
	CAN_BitTimingTypeDef tq;
	can.Register=CAN1;
	//Los prescaladores se seleccionan por n=1,2,...,8. Siendo 2^n el valor del preescalador
	SystClock_Init(2,1,80,1,0,0);//SYSCLK -> PLLP, SYSPLL -> HSI, SYSCLK -> 80MHz, preAHB1 -> divided by 2^1
	//preAPB1 -> Not divided, preAPB2 -> not divided, APB1 = 40MHZ, APB2=40MHz.
	//NVIC_SetCFGR(CAN1_Rx0_IRQ, 3);


	CANx_GPIO(GPIOB,8);//CAN RX
	CANx_GPIO(GPIOB,9);//CAN TX

	CANx_SetParFLTR(&FLTR[0], 0, CAN_FS1R_S32, 0x13, 0, 0x13, 0, CAN_FM1R_MaskMode,
			CAN_FFA1R_FIFO0, false);
	CANx_SetParDualFLTR(&dualFLTR[0], 0, 0x1212, 0x1212, 0x1212, 0x1212);
	//0->Filter 0; CAN_FS1R_S32->32 bits scale; 0xFFFF->IDL,  0xFFFF->IDH;  0xFFFF->MaskL,  0xFFFF->MaskH;
	//CAN_FM1R_MaskMode-> ID in mask mode; CAN_FFA1R_FIFO0-> assigned to FIFO 0, false->Standard ID
	//CANx_SetParFLTR(&FLTR[1], 1, CAN_FS1R_D16, 1200, 1201, 0xFFFF, 0xFFFF, CAN_FM1R_MaskMode, CAN_FFA1R_FIFO1);

	//Time quanta Parameters
	tq.ntq = 20;//20 times for 40MHz
	tq.kbps = 1000000;//1Mbps
	tq.SJW = 0;//SJW=1

	CANx_Init(&can, FLTR, dualFLTR, &tq, false, 0, 1);//can struct; array of sturct FLTR; tq struct; false->No dual mode; 0->Number of filter for CAN2;
	//3->Number of filters to configure

    /* Loop forever */
	while(1){

		/*Code for polling*/
		for (i = 0; i < 100000000; ++i);// Retardo
		CANx_TxData(&can, 0x12, dato, dato, 8, false, 0);
		dato++;
		//for (i = 0; i < 100000000; ++i);// Retardo
		//CANx_TxData(&can, 0x1FFFFFFF, 0x11112222, 0x11112222, 8, true, 1);
		//CANx_RxFIFO0(&can, dataRx);
		//CANx_RxFIFO1(&can, dataRx);

	}
}

void CANx_SetParFLTR(
		CAN_FilterTypeDef * FLTR,
		uint8_t index,
		uint8_t scale,
		uint16_t IDL,
		uint16_t IDH,
		uint16_t MaskL,
		uint32_t MaskH,
		uint8_t mode,
		uint8_t FIFO,
		bool IDE)
{
	FLTR->indexFltr=index;
	FLTR->bitscale=scale;
	FLTR->ID_L=IDL;
	FLTR->ID_H=IDH;
	FLTR->Mask_L=MaskL;
	FLTR->Mask_H=MaskH;
	FLTR->modeFltr=mode;
	FLTR->FIFO=FIFO;
	FLTR->IDE= IDE;
}

void CANx_SetParDualFLTR(
		CAN_DualFilterID_n_MaskTypeDef * FLTR,
		uint8_t index,
		uint16_t IDL,
		uint16_t IDH,
		uint16_t MaskL,
		uint16_t MaskH)
{
	FLTR->indexFltr=index;
	FLTR->ID_L=IDL;
	FLTR->ID_H=IDH;
	FLTR->Mask_L= MaskL;
	FLTR->Mask_H= MaskH;
}
